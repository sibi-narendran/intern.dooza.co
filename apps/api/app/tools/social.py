"""
Social Media Tools

Tools for social media content creation including:
- LinkedIn post generation
- Twitter/X thread generation
- Blog outline creation
- Caption generation

Production-ready with:
- Input validation
- Structured output
- UI schemas for frontend rendering
"""

from __future__ import annotations
import logging
from typing import Any, ClassVar, Dict, List, Literal

from pydantic import BaseModel, Field

from app.tools.base import (
    DoozaTool,
    ToolMetadata,
    ToolUISchema,
    UIDisplayType,
    UISection,
    FieldMapping,
)

logger = logging.getLogger(__name__)

# ============================================================================
# Constants
# ============================================================================

# Platform constraints
LINKEDIN_MAX_LENGTH = 3000
TWITTER_MAX_LENGTH = 280
INSTAGRAM_MAX_CAPTION = 2200

# Content generation settings
DEFAULT_HASHTAG_COUNT = 5


# ============================================================================
# Tool Input Schemas
# ============================================================================

class GenerateLinkedInPostInput(BaseModel):
    """Input schema for LinkedIn post generation."""
    topic: str = Field(
        description="The topic or subject to write about",
        min_length=3,
        max_length=500,
    )
    tone: str = Field(
        default="professional",
        description="Tone of the post: professional, thought-leader, storytelling, educational",
    )
    include_hashtags: bool = Field(
        default=True,
        description="Whether to include relevant hashtags",
    )
    call_to_action: str = Field(
        default="",
        description="Optional call-to-action to include at the end",
    )


class GenerateTwitterThreadInput(BaseModel):
    """Input schema for Twitter thread generation."""
    topic: str = Field(
        description="The topic or subject for the thread",
        min_length=3,
        max_length=500,
    )
    num_tweets: int = Field(
        default=5,
        description="Number of tweets in the thread (3-15)",
        ge=3,
        le=15,
    )
    tone: str = Field(
        default="engaging",
        description="Tone: engaging, educational, controversial, storytelling",
    )
    include_hook: bool = Field(
        default=True,
        description="Start with a strong hook tweet",
    )


class GenerateBlogOutlineInput(BaseModel):
    """Input schema for blog outline generation."""
    topic: str = Field(
        description="The blog post topic",
        min_length=3,
        max_length=500,
    )
    target_audience: str = Field(
        default="",
        description="Who is the target reader",
    )
    num_sections: int = Field(
        default=5,
        description="Number of main sections (3-10)",
        ge=3,
        le=10,
    )
    include_seo_tips: bool = Field(
        default=True,
        description="Include SEO optimization suggestions",
    )


class GenerateCaptionInput(BaseModel):
    """Input schema for social media caption generation."""
    description: str = Field(
        description="Description of the content/image the caption is for",
        min_length=3,
        max_length=500,
    )
    platform: str = Field(
        default="instagram",
        description="Target platform: instagram, facebook, tiktok",
    )
    tone: str = Field(
        default="casual",
        description="Tone: casual, professional, playful, inspirational",
    )
    include_emojis: bool = Field(
        default=True,
        description="Whether to include emojis",
    )
    hashtag_count: int = Field(
        default=10,
        description="Number of hashtags to include",
        ge=0,
        le=30,
    )


# ============================================================================
# Content Generation Functions
# ============================================================================

def generate_linkedin_content(
    topic: str,
    tone: str,
    include_hashtags: bool,
    call_to_action: str,
) -> Dict[str, Any]:
    """
    Generate a LinkedIn post structure.
    
    This creates a template structure that the LLM will fill.
    The actual content is generated by the agent using this structure.
    """
    # Build the post template based on tone
    templates = {
        "professional": {
            "hook_style": "Start with a bold professional insight",
            "body_style": "Share expertise with specific examples",
            "cta_style": "End with a thought-provoking question",
        },
        "thought-leader": {
            "hook_style": "Open with a contrarian or surprising take",
            "body_style": "Challenge conventional wisdom with evidence",
            "cta_style": "Invite discussion and different perspectives",
        },
        "storytelling": {
            "hook_style": "Begin with 'Last week something happened...'",
            "body_style": "Share personal experience with lessons",
            "cta_style": "Connect story to universal truth",
        },
        "educational": {
            "hook_style": "Promise specific value: 'Here's how to...'",
            "body_style": "Break down complex topic into steps",
            "cta_style": "Offer to share more or ask follow-up",
        },
    }
    
    template = templates.get(tone, templates["professional"])
    
    return {
        "success": True,
        "platform": "linkedin",
        "topic": topic,
        "tone": tone,
        "structure": {
            "hook": template["hook_style"],
            "body": template["body_style"],
            "call_to_action": call_to_action or template["cta_style"],
        },
        "guidelines": {
            "max_length": LINKEDIN_MAX_LENGTH,
            "use_line_breaks": True,
            "hashtag_count": DEFAULT_HASHTAG_COUNT if include_hashtags else 0,
        },
        "best_practices": [
            "First line is crucial - make it count",
            "Use white space between paragraphs",
            "Include 1-2 relevant statistics if possible",
            "Tag relevant people or companies sparingly",
            "Post during business hours (Tue-Thu, 8-10 AM or 5-6 PM)",
        ],
    }


def generate_twitter_thread_content(
    topic: str,
    num_tweets: int,
    tone: str,
    include_hook: bool,
) -> Dict[str, Any]:
    """Generate a Twitter thread structure."""
    
    thread_structure = []
    
    # First tweet (hook)
    if include_hook:
        thread_structure.append({
            "position": 1,
            "type": "hook",
            "guidance": "Grab attention. Make them NEED to read more.",
            "max_chars": TWITTER_MAX_LENGTH,
        })
        remaining = num_tweets - 2  # Minus hook and closer
    else:
        remaining = num_tweets - 1  # Minus closer
    
    # Body tweets
    for i in range(remaining):
        thread_structure.append({
            "position": len(thread_structure) + 1,
            "type": "body",
            "guidance": f"Point {i + 1}: Deliver value, end with intrigue",
            "max_chars": TWITTER_MAX_LENGTH,
        })
    
    # Closing tweet
    thread_structure.append({
        "position": num_tweets,
        "type": "closer",
        "guidance": "Summarize, CTA, ask for retweet/follow",
        "max_chars": TWITTER_MAX_LENGTH,
    })
    
    return {
        "success": True,
        "platform": "twitter",
        "topic": topic,
        "tone": tone,
        "thread_length": num_tweets,
        "thread_structure": thread_structure,
        "best_practices": [
            "End each tweet mid-thought to encourage reading",
            "Use numbers: '5 things I learned...'",
            "Include 1-2 hashtags max per tweet",
            "Add a relevant image to the first tweet",
            "Reply to your own thread to boost engagement",
        ],
    }


def generate_blog_outline_content(
    topic: str,
    target_audience: str,
    num_sections: int,
    include_seo_tips: bool,
) -> Dict[str, Any]:
    """Generate a blog post outline structure."""
    
    sections = [
        {
            "position": 0,
            "type": "introduction",
            "title": "Introduction",
            "guidance": "Hook reader, state the problem, preview the solution",
            "word_count_target": "100-150 words",
        }
    ]
    
    for i in range(num_sections):
        sections.append({
            "position": i + 1,
            "type": "main_section",
            "title": f"Section {i + 1}: [Subheading]",
            "guidance": "One key point per section with examples",
            "word_count_target": "200-300 words",
        })
    
    sections.append({
        "position": num_sections + 1,
        "type": "conclusion",
        "title": "Conclusion",
        "guidance": "Summarize key points, strong CTA",
        "word_count_target": "100-150 words",
    })
    
    result = {
        "success": True,
        "content_type": "blog_outline",
        "topic": topic,
        "target_audience": target_audience or "General audience",
        "sections": sections,
        "total_sections": len(sections),
        "estimated_word_count": f"{(num_sections + 2) * 200}-{(num_sections + 2) * 300}",
    }
    
    if include_seo_tips:
        result["seo_recommendations"] = [
            "Include primary keyword in title and H1",
            "Use keyword variations in H2 subheadings",
            "Write meta description (150-160 chars)",
            "Add internal links to related content",
            "Include alt text for all images",
            "Aim for 1500+ words for comprehensive coverage",
        ]
    
    return result


def generate_caption_content(
    description: str,
    platform: str,
    tone: str,
    include_emojis: bool,
    hashtag_count: int,
) -> Dict[str, Any]:
    """Generate a social media caption structure."""
    
    platform_specs = {
        "instagram": {
            "max_length": INSTAGRAM_MAX_CAPTION,
            "hashtag_placement": "End of caption or first comment",
            "optimal_length": "125-150 chars for engagement",
        },
        "facebook": {
            "max_length": 63206,
            "hashtag_placement": "Sparingly, 1-2 max",
            "optimal_length": "40-80 chars for engagement",
        },
        "tiktok": {
            "max_length": 2200,
            "hashtag_placement": "End of caption",
            "optimal_length": "Keep it short, punchy",
        },
    }
    
    spec = platform_specs.get(platform, platform_specs["instagram"])
    
    return {
        "success": True,
        "platform": platform,
        "description": description,
        "tone": tone,
        "use_emojis": include_emojis,
        "hashtag_count": hashtag_count,
        "platform_specs": spec,
        "caption_structure": {
            "hook": "First line to stop the scroll",
            "body": "Value or story in 2-3 sentences",
            "cta": "Clear action: comment, save, share",
        },
        "best_practices": [
            "Front-load the most important info",
            "Use line breaks for readability",
            "Ask a question to boost comments",
            "Include a clear call-to-action",
        ],
    }


# ============================================================================
# Tool Classes
# ============================================================================

class GenerateLinkedInPostTool(DoozaTool):
    """
    Tool for generating LinkedIn posts.
    
    Creates professional, engaging LinkedIn content with proper
    structure, tone, and platform-specific optimizations.
    """
    
    name: str = "social_generate_linkedin_post"
    description: str = (
        "Generate a LinkedIn post for a given topic. "
        "Returns structured content with hook, body, and CTA."
    )
    args_schema: type = GenerateLinkedInPostInput
    
    tool_metadata: ClassVar[ToolMetadata] = ToolMetadata(
        slug="social.generate_linkedin_post",
        category="social",
        name="Generate LinkedIn Post",
        description="Create engaging LinkedIn content",
        min_tier="free",
        ui_schema=ToolUISchema(
            display=UIDisplayType.KEY_VALUE,
            title="LinkedIn Post",
            summary_template="Topic: {topic} • Tone: {tone}",
            fields=[
                FieldMapping("topic", "Topic"),
                FieldMapping("tone", "Tone"),
                FieldMapping("structure.hook", "Hook Style"),
                FieldMapping("structure.body", "Body Style"),
                FieldMapping("structure.call_to_action", "CTA"),
            ],
            sections=[
                UISection(
                    id="content",
                    label="Post Structure",
                    display=UIDisplayType.KEY_VALUE,
                    icon="FileText",
                    fields=[
                        FieldMapping("structure.hook", "Hook"),
                        FieldMapping("structure.body", "Body"),
                        FieldMapping("structure.call_to_action", "Call to Action"),
                    ],
                ),
                UISection(
                    id="guidelines",
                    label="Guidelines",
                    display=UIDisplayType.KEY_VALUE,
                    icon="Info",
                    fields=[
                        FieldMapping("guidelines.max_length", "Max Length", "number"),
                        FieldMapping("guidelines.hashtag_count", "Hashtags", "number"),
                    ],
                ),
            ],
        ),
    )
    
    async def _arun(
        self,
        topic: str,
        tone: str = "professional",
        include_hashtags: bool = True,
        call_to_action: str = "",
    ) -> Dict[str, Any]:
        """Generate LinkedIn post structure."""
        try:
            return generate_linkedin_content(
                topic=topic,
                tone=tone,
                include_hashtags=include_hashtags,
                call_to_action=call_to_action,
            )
        except Exception as e:
            logger.error(f"Error generating LinkedIn post: {e}", exc_info=True)
            return {
                "success": False,
                "error": f"Failed to generate LinkedIn post: {str(e)}",
                "topic": topic,
            }
    
    def _run(
        self,
        topic: str,
        tone: str = "professional",
        include_hashtags: bool = True,
        call_to_action: str = "",
    ) -> Dict[str, Any]:
        """Sync version."""
        import asyncio
        return asyncio.run(self._arun(topic, tone, include_hashtags, call_to_action))


class GenerateTwitterThreadTool(DoozaTool):
    """
    Tool for generating Twitter/X threads.
    
    Creates engaging thread structures with hooks, body content,
    and proper thread formatting.
    """
    
    name: str = "social_generate_twitter_thread"
    description: str = (
        "Generate a Twitter/X thread structure for a topic. "
        "Returns numbered tweets with hooks and closers."
    )
    args_schema: type = GenerateTwitterThreadInput
    
    tool_metadata: ClassVar[ToolMetadata] = ToolMetadata(
        slug="social.generate_twitter_thread",
        category="social",
        name="Generate Twitter Thread",
        description="Create engaging Twitter/X threads",
        min_tier="free",
        ui_schema=ToolUISchema(
            display=UIDisplayType.DATA_TABLE,
            title="Twitter Thread",
            summary_template="{thread_length} tweets • {tone} tone",
            fields=[
                FieldMapping("thread_structure", "Thread Structure"),
            ],
        ),
    )
    
    async def _arun(
        self,
        topic: str,
        num_tweets: int = 5,
        tone: str = "engaging",
        include_hook: bool = True,
    ) -> Dict[str, Any]:
        """Generate Twitter thread structure."""
        try:
            return generate_twitter_thread_content(
                topic=topic,
                num_tweets=num_tweets,
                tone=tone,
                include_hook=include_hook,
            )
        except Exception as e:
            logger.error(f"Error generating Twitter thread: {e}", exc_info=True)
            return {
                "success": False,
                "error": f"Failed to generate Twitter thread: {str(e)}",
                "topic": topic,
            }
    
    def _run(
        self,
        topic: str,
        num_tweets: int = 5,
        tone: str = "engaging",
        include_hook: bool = True,
    ) -> Dict[str, Any]:
        """Sync version."""
        import asyncio
        return asyncio.run(self._arun(topic, num_tweets, tone, include_hook))


class GenerateBlogOutlineTool(DoozaTool):
    """
    Tool for generating blog post outlines.
    
    Creates structured outlines with sections, word count targets,
    and optional SEO recommendations.
    """
    
    name: str = "social_generate_blog_outline"
    description: str = (
        "Generate a structured blog post outline with sections and guidance. "
        "Optionally includes SEO recommendations."
    )
    args_schema: type = GenerateBlogOutlineInput
    
    tool_metadata: ClassVar[ToolMetadata] = ToolMetadata(
        slug="social.generate_blog_outline",
        category="social",
        name="Generate Blog Outline",
        description="Create structured blog post outlines",
        min_tier="free",
        ui_schema=ToolUISchema(
            display=UIDisplayType.DATA_TABLE,
            title="Blog Outline",
            summary_template="{total_sections} sections • {estimated_word_count} words",
            fields=[
                FieldMapping("sections", "Sections"),
            ],
            sections=[
                UISection(
                    id="outline",
                    label="Outline",
                    display=UIDisplayType.DATA_TABLE,
                    icon="List",
                    fields=[
                        FieldMapping("sections", "Sections"),
                    ],
                ),
                UISection(
                    id="seo",
                    label="SEO Tips",
                    display=UIDisplayType.ISSUES_LIST,
                    icon="Search",
                    fields=[
                        FieldMapping("seo_recommendations", "Recommendations"),
                    ],
                ),
            ],
        ),
    )
    
    async def _arun(
        self,
        topic: str,
        target_audience: str = "",
        num_sections: int = 5,
        include_seo_tips: bool = True,
    ) -> Dict[str, Any]:
        """Generate blog outline structure."""
        try:
            return generate_blog_outline_content(
                topic=topic,
                target_audience=target_audience,
                num_sections=num_sections,
                include_seo_tips=include_seo_tips,
            )
        except Exception as e:
            logger.error(f"Error generating blog outline: {e}", exc_info=True)
            return {
                "success": False,
                "error": f"Failed to generate blog outline: {str(e)}",
                "topic": topic,
            }
    
    def _run(
        self,
        topic: str,
        target_audience: str = "",
        num_sections: int = 5,
        include_seo_tips: bool = True,
    ) -> Dict[str, Any]:
        """Sync version."""
        import asyncio
        return asyncio.run(self._arun(topic, target_audience, num_sections, include_seo_tips))


class GenerateCaptionTool(DoozaTool):
    """
    Tool for generating social media captions.
    
    Creates platform-optimized captions for Instagram, Facebook,
    and TikTok with proper structure and hashtags.
    """
    
    name: str = "social_generate_caption"
    description: str = (
        "Generate a social media caption for Instagram, Facebook, or TikTok. "
        "Returns platform-optimized content with hashtag suggestions."
    )
    args_schema: type = GenerateCaptionInput
    
    tool_metadata: ClassVar[ToolMetadata] = ToolMetadata(
        slug="social.generate_caption",
        category="social",
        name="Generate Caption",
        description="Create platform-optimized captions",
        min_tier="free",
        ui_schema=ToolUISchema(
            display=UIDisplayType.KEY_VALUE,
            title="Social Caption",
            summary_template="{platform} • {tone} tone",
            fields=[
                FieldMapping("platform", "Platform"),
                FieldMapping("tone", "Tone"),
                FieldMapping("caption_structure.hook", "Hook"),
                FieldMapping("caption_structure.body", "Body"),
                FieldMapping("caption_structure.cta", "CTA"),
            ],
        ),
    )
    
    async def _arun(
        self,
        description: str,
        platform: str = "instagram",
        tone: str = "casual",
        include_emojis: bool = True,
        hashtag_count: int = 10,
    ) -> Dict[str, Any]:
        """Generate caption structure."""
        try:
            return generate_caption_content(
                description=description,
                platform=platform,
                tone=tone,
                include_emojis=include_emojis,
                hashtag_count=hashtag_count,
            )
        except Exception as e:
            logger.error(f"Error generating caption: {e}", exc_info=True)
            return {
                "success": False,
                "error": f"Failed to generate caption: {str(e)}",
                "description": description,
            }
    
    def _run(
        self,
        description: str,
        platform: str = "instagram",
        tone: str = "casual",
        include_emojis: bool = True,
        hashtag_count: int = 10,
    ) -> Dict[str, Any]:
        """Sync version."""
        import asyncio
        return asyncio.run(self._arun(description, platform, tone, include_emojis, hashtag_count))


# ============================================================================
# Tool Factory
# ============================================================================

def get_social_tools() -> List[DoozaTool]:
    """
    Get all social media tools for registration.
    
    Returns:
        List of social media tool instances
    """
    return [
        GenerateLinkedInPostTool(),
        GenerateTwitterThreadTool(),
        GenerateBlogOutlineTool(),
        GenerateCaptionTool(),
    ]
